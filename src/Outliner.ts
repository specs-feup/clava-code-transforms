import ClavaJoinPoints from "@specs-feup/clava/api/clava/ClavaJoinPoints.js";
import { BuiltinType, Call, Decl, DeclStmt, ElaboratedType, Expression, FunctionJp, FunctionType, GotoStmt, Joinpoint, LabelDecl, LabelStmt, MemberAccess, Param, ParenExpr, PointerType, ReturnStmt, Statement, Type, TypedefType, UnaryOp, Vardecl, Varref } from "@specs-feup/clava/api/Joinpoints.js";
import IdGenerator from "@specs-feup/lara/api/lara/util/IdGenerator.js";
import JoinPoints from "@specs-feup/lara/api/weaver/JoinPoints.js";
import Query from "@specs-feup/lara/api/weaver/Query.js";

export default class Outliner {
    #verbose: boolean;
    #defaultPrefix: string;

    constructor() {
        this.#verbose = true;
        this.#defaultPrefix = "__outlined_function_";
    }

    /**
     * Sets the verbosity of the outliner, with false being the equivalent of a silent mode (true is the default)
     * @param {boolean} verbose - the verbosity of the outliner
     */
    setVerbosity(verbose: boolean): void {
        this.#verbose = verbose;
    }

    /**
     * Sets the prefix used for the autogenerated names of the outlined functions
     * @param {string} prefix - the prefix to be used
     */
    setDefaultPrefix(prefix: string): void {
        this.#defaultPrefix = prefix;
    }

    /**
     * Applies function outlining to a code region delimited by two statements.
     * Function outlining is the process of removing a section of code from a function and placing it in a new function.
     * The beginning and end of the code region must be at the same scope level.
     * @param {statement} begin - the first statement of the outlining region 
     * @param {statement} end - the last statement of the outlining region
     * @returns an array with the joinpoints of the outlined function and the call to it. 
     * These values are merely references, and all changes have already been committed to the AST at this point
     */
    outline(begin: Statement, end: Statement): [FunctionJp, Call] | [null, null] {
        return this.outlineWithName(begin, end, this.#generateFunctionName())
    }

    /**
     * Applies function outlining to a code region delimited by two statements.
     * Function outlining is the process of removing a section of code from a function and placing it in a new function.
     * The beginning and end of the code region must be at the same scope level.
     * @param {statement} begin - the first statement of the outlining region 
     * @param {statement} end - the last statement of the outlining region
     * @param {string} functionName - the name to give to the outlined function
     * @returns an array with the joinpoints of the outlined function and the call to it. 
     * These values are merely references, and all changes have already been committed to the AST at this point
     */
    outlineWithName(begin: Statement, end: Statement, functionName: string): [FunctionJp, Call] | [null, null] {
        this.#printMsg("Attempting to outline a region into a function named \"" + functionName + "\"");

        //------------------------------------------------------------------------------
        if (!this.checkOutline(begin, end)) {
            this.#printMsg("Provided code region is not outlinable! Aborting...");
            return [null, null];
        }
        this.#printMsg("Provided code region is outlinable");

        //------------------------------------------------------------------------------
        const wrappers = this.#wrapBeginAndEnd(begin, end);
        begin = wrappers[0];
        end = wrappers[1];
        this.#printMsg("Wrapped outline region with begin and ending comments");

        //------------------------------------------------------------------------------
        //const parentFun: FunctionJp | null = this.#findParentFunction(begin);
        const parentFun = begin.getAncestor("function") as FunctionJp | null;
        if (parentFun == null) {
            this.#printMsg("Could not find parent function for the outline region");
            return [null, null];
        }
        const split = this.#splitRegions(parentFun, begin, end);

        let region = split[1];
        const prologue = split[0];
        const epilogue = split[2];
        this.#printMsg("Found " + region.length + " statements for the outline region");
        this.#printMsg("Prologue has " + prologue.length + " statements, and epilogue has " + epilogue.length);

        //------------------------------------------------------------------------------
        const globals = this.#findGlobalVars();
        this.#printMsg("Found " + globals.length + " global variable(s)");

        //------------------------------------------------------------------------------
        const callPlaceholder = ClavaJoinPoints.stmtLiteral("//placeholder for the call to " + functionName);
        begin.insertBefore(callPlaceholder);
        this.#printMsg("Created a placeholder call to the new function");

        //------------------------------------------------------------------------------
        const declareBefore = this.#findDeclsWithDependency(region, epilogue);
        region = region.filter((stmt) => !declareBefore.includes(stmt as DeclStmt));
        for (var i = declareBefore.length - 1; i >= 0; i--) {
            const decl = declareBefore[i];
            decl.detach();
            begin.insertBefore(decl);
            prologue.push(decl);
        }
        this.#printMsg("Moved declarations from outline region to immediately before the region");

        //------------------------------------------------------------------------------
        const referencedInRegion = this.#findRefsInRegion(region);
        const funParams = this.#createParams(referencedInRegion);
        const fun = this.#createFunction(functionName, region, funParams);
        this.#printMsg("Successfully created function \"" + functionName + "\"");

        //------------------------------------------------------------------------------
        const callArgs = this.#createArgs(fun, prologue, parentFun);
        let call = this.#createCall(callPlaceholder, fun, callArgs);
        this.#printMsg("Successfully created call to \"" + functionName + "\"");

        //------------------------------------------------------------------------------
        // At this point, if the function has a premature return, it will be returning a value
        // of that type instead of void. We change the function to return void now at this point,
        // by doing a) adding a new parameter for the return value of the premature return; b) a new
        // boolean parameter that is set to true if the function returns prematurely; c) we declare these
        // two variables before the function call and d) if the boolean is set to 1 after the call, we
        // return from the caller with the value returned by the callee.
        const newCall = this.#ensureVoidReturn(fun, call);
        if (newCall != null) {
            this.#printMsg("Ensured that the outlined function returns void by parameterizing the early return(s)");
            call = newCall;
        }
        else {
            this.#printMsg("No need to ensure that the outlined function returns void, as it has no early returns");
        }

        //------------------------------------------------------------------------------
        // Remove some of the redundancies introduced by the outlining process
        this.#removeRedundancies(fun);
        this.#removeRedundancies(call);

        //------------------------------------------------------------------------------
        // Victory, at last
        begin.detach();
        end.detach();
        this.#printMsg("Outliner cleanup finished");

        return [fun, call];
    }

    #removeRedundancies(startingPoint: Joinpoint): void {
        const unaryOps = [];

        for (const unaryOp of Query.searchFrom(startingPoint, UnaryOp)) {
            unaryOps.push(unaryOp);
        }

        for (const op of unaryOps) {
            if (op.children.length == 0) {
                continue;
            }
            const child = op.children[0];

            if (child instanceof ParenExpr) {
                const grandchild = child.children[0];

                const isValid = op.kind == "addr_of" && grandchild instanceof UnaryOp && grandchild.kind == "deref";
                if (isValid) {
                    op.replaceWith(grandchild.children[0]);
                }
            }
        }
    }

    /**
     * Verifies if a code region can undergo function outlining. 
     * This check is performed automatically by the outliner itself, but it can be invoked manually if desired.
     * @param {statement} begin - the first statement of the outlining region 
     * @param {statement} end - the last statement of the outlining region 
     * @returns true if the outlining region is valid, false otherwise
     */
    checkOutline(begin: Statement, end: Statement): boolean {
        var outlinable = true;
        //const parentFun = this.#findParentFunction(begin);
        const parentFun = begin.getAncestor("function") as FunctionJp | null;

        if (parentFun == null) {
            this.#printMsg("Requirement not met: outlinable region must be inside a function");
            outlinable = false;
        }
        if (begin.parent.astId != end.parent.astId) {
            this.#printMsg("Requirement not met: begin and end joinpoints are not at the same scope level");
            outlinable = false;
        }
        if (!outlinable) {
            return false;
        }

        // now that we have a baseline valid region, let's check for specific requirements within the region
        // TS conversion: we need to explicitly cast the parentFun to FunctionJp because it could be null,
        // despite having checked for it earlier
        const region = this.#splitRegions(parentFun as FunctionJp, begin, end)[1];

        if (this.#checkOutOfRegionGotos(region)) {
            this.#printMsg("Requirement not met: outlinable region must not contain any goto statements that jump outside of the region");
            outlinable = false;
        }
        return outlinable;
    }

    #checkOutOfRegionGotos(region: Statement[]): boolean {
        const gotoLabels = [];
        const labels: string[] = [];

        for (const stmt of region) {
            for (const goto of Query.searchFrom(stmt, GotoStmt)) {
                gotoLabels.push(goto.label.code);
            }
            for (const label of Query.searchFrom(stmt, LabelStmt)) {
                labels.push(label.code);
            }
        }
        return !gotoLabels.every(label => labels.includes(label));
    }

    #ensureVoidReturn(fun: FunctionJp, call: Call): Call | null {
        const returnStmts = this.#findNonvoidReturnStmts([fun]);

        if (returnStmts.length == 0) {
            return null;
        }

        // actions before the function call
        const type = returnStmts[0].children[0].type;
        const resId = IdGenerator.next("__rtr_val_");
        const resVar = ClavaJoinPoints.varDeclNoInit(resId, type);

        const boolId = IdGenerator.next("__rtr_flag_");
        const boolVar = ClavaJoinPoints.varDecl(boolId, ClavaJoinPoints.integerLiteral(0));

        const resVarRef = resVar.varref();
        const boolVarRef = boolVar.varref();

        call.insertBefore(resVar);
        call.insertBefore(boolVar);

        // actions in the function itself
        const params = this.#createParams([resVarRef, boolVarRef]);
        fun.addParam(params[0].name, params[0].type);
        fun.addParam(params[1].name, params[1].type);

        for (const ret of returnStmts) {
            const resVarParam = fun.params[fun.params.length - 2];
            const derefResVarParam = ClavaJoinPoints.parenthesis(ClavaJoinPoints.unaryOp("*", resVarParam.varref()));
            const retVal = ret.children[0] as Expression;
            retVal.detach();
            const op1 = ClavaJoinPoints.binaryOp("=", derefResVarParam, retVal, resVarParam.type);
            ret.insertBefore(ClavaJoinPoints.exprStmt(op1));

            const boolVarParam = fun.params[fun.params.length - 1];
            const newVarref = ClavaJoinPoints.varRef(boolVarParam);
            const derefBoolVarParam = ClavaJoinPoints.parenthesis(ClavaJoinPoints.unaryOp("*", newVarref));
            const trueVal = ClavaJoinPoints.integerLiteral(1);
            const op2 = ClavaJoinPoints.binaryOp("=", derefBoolVarParam, trueVal, boolVarParam.type);
            ret.insertBefore(op2);
        }
        fun.setType(ClavaJoinPoints.type("void"));


        // actions on the function call
        const resVarAddr = ClavaJoinPoints.unaryOp("&", resVarRef);
        const boolVarAddr = ClavaJoinPoints.unaryOp("&", boolVarRef);
        const allArgs = call.argList.concat([resVarAddr, boolVarAddr]);
        call = this.#createCall(call, fun, allArgs);

        // actions after the function call
        const returnStmt = ClavaJoinPoints.returnStmt(resVarRef);
        const scope = ClavaJoinPoints.scope();
        scope.setFirstChild(returnStmt);
        const ifStmt = ClavaJoinPoints.ifStmt(boolVarRef, scope);
        call.insertAfter(ifStmt);

        return call;
    }

    #wrapBeginAndEnd(begin: Statement, end: Statement): [Statement, Statement] {
        const beginWrapper = ClavaJoinPoints.stmtLiteral("//begin of the outline region");
        const endWrapper = ClavaJoinPoints.stmtLiteral("//end of the outline region");
        begin.insertBefore(beginWrapper);
        end.insertAfter(endWrapper);
        return [beginWrapper, endWrapper];
    }

    /**
     * @deprecated - use .getAncestor(FunctionJp) instead
     */
    #findParentFunction(jp: Joinpoint): FunctionJp | null {
        while (!(jp instanceof FunctionJp)) {
            if (jp instanceof File) {
                return null;
            }
            jp = jp.parent;
        }
        return jp;
    }

    #findGlobalVars() {
        const globals = [];
        for (const decl of Query.search(Vardecl)) {
            if (decl.isGlobal) {
                globals.push(decl);
            }
        }
        return globals;
    }

    #createCall(placeholder: Statement | Call, fun: FunctionJp, args: Expression[]): Call {
        const call = ClavaJoinPoints.call(fun, ...args);
        placeholder.replaceWith(call);
        return call;
    }

    #createArgs(fun: FunctionJp, prologue: Statement[], parentFun: FunctionJp): Expression[] {
        const decls = [];
        // get decls from the prologue
        for (const stmt of prologue) {
            for (const decl of Query.searchFrom(stmt, Vardecl)) {
                decls.push(decl);
            }
        }
        // get decls from the parent function params
        for (const param of Query.searchFrom(parentFun, Param)) {
            decls.push(param.definition);
        }
        // no need to handle global vars - they are not parameters

        const args = [];
        for (const param of fun.params) {
            for (const decl of decls) {
                if (decl.name === param.name) {
                    const ref = ClavaJoinPoints.varRef(decl);

                    if (param.type instanceof PointerType) {
                        if (ref.type instanceof BuiltinType || ref.type instanceof TypedefType || ref.type instanceof ElaboratedType) {
                            const addressOfScalar = ClavaJoinPoints.unaryOp("&", ref);
                            args.push(addressOfScalar);
                        }
                    }
                    else {
                        args.push(ref);
                    }
                    break;
                }
            }
        }

        return args;
    }

    #createFunction(name: string, region: Statement[], params: Param[]): FunctionJp {
        let oldFun: Joinpoint = region[0];
        while (!(oldFun instanceof FunctionJp)) {
            oldFun = oldFun.parent;
        }

        if (oldFun == null) {
            throw new Error("Could not find parent function for the outline region");
        }

        let retType = ClavaJoinPoints.type("void");
        const returnStmts = this.#findNonvoidReturnStmts(region);
        if (returnStmts.length > 0) {
            retType = returnStmts[0].children[0].type;
            this.#printMsg("Found " + returnStmts.length + " return statement(s) in the outline region");
        }

        const fun = ClavaJoinPoints.functionDecl(name, retType, ...params);
        oldFun.insertBefore(fun);
        const scope = ClavaJoinPoints.scope();
        fun.setBody(scope);

        for (const stmt of region) {
            stmt.detach();
            scope.insertEnd(stmt);
        }

        // make sure scalar refs are now dereferenced pointers to params
        this.#scalarsToPointers(region, params);
        return fun;
    }

    #findNonvoidReturnStmts(startingPoints: Joinpoint[]) {
        const returnStmts = [];
        for (const stmt of startingPoints) {
            for (const ret of Query.searchFrom(stmt, ReturnStmt)) {
                if (ret.numChildren > 0) {
                    returnStmts.push(ret);
                }
            }
        }
        return returnStmts;
    }

    #scalarsToPointers(region: Statement[], params: Param[]) {
        for (const stmt of region) {

            for (const varref of Query.searchFrom(stmt, Varref)) {

                for (const param of params) {
                    if (param.name === varref.name) {
                        if (varref.type instanceof ElaboratedType) {
                            const newVarref = ClavaJoinPoints.varRef(param);
                            varref.replaceWith(newVarref);
                        }
                        if (varref.type instanceof BuiltinType || varref.type instanceof TypedefType) {
                            const newVarref = ClavaJoinPoints.varRef(param);

                            if (varref.parent != undefined && varref.parent instanceof MemberAccess) {
                                varref.parent.setArrow(true);
                                varref.replaceWith(newVarref);
                            }
                            else {
                                const op = ClavaJoinPoints.parenthesis(ClavaJoinPoints.unaryOp("*", newVarref));
                                varref.replaceWith(op);
                            }

                        }
                    }
                }
            }
        }
    }

    #createParams(varrefs: Varref[]): Param[] {
        const params: Param[] = [];

        for (const ref of varrefs) {
            const name = ref.name;
            const varType = ref.type;

            if (varType.instanceOf(["arrayType", "adjustedType", "pointerType"])) {
                const param = ClavaJoinPoints.param(name, varType);
                params.push(param);
            }
            // unsure if typedefType is always a scalar
            else if (varType.instanceOf(["builtinType", "typedefType", "elaboratedType"])) {
                const newType = ClavaJoinPoints.pointer(varType);
                const param = ClavaJoinPoints.param(name, newType);
                params.push(param);
            }
            else {
                this.#printMsg(`Unsupported param type "${varType.joinPointType}" for C/C++ type ${varType.code}`, true);
            }
        }
        this.#printMsg("Created " + params.length + " param(s) for the outlined function");
        return params;
    }

    #findRefsInRegion(region: Statement[]): Varref[] {
        const decls = [];
        const declsNames = [];
        for (const stmt of region) {
            for (const decl of Query.searchFrom(stmt, Vardecl)) {
                decls.push(decl);
                declsNames.push(decl.name);
            }
        }

        const varrefs: Varref[] = [];
        const varrefsNames: string[] = [];

        for (const stmt of region) {
            for (const varref of Query.searchFrom(stmt, Varref)) {
                // may need to filter for other types, like macros, etc
                // select all varrefs with no matching decl in the region, except globals
                try {
                    const isValid = this.#isValidVarref(varref);
                    if (!isValid) {
                        continue;
                    }

                    const condA = !varrefsNames.includes(varref.name);
                    const condB = !declsNames.includes(varref.name);
                    const condC = !varref.vardecl.isGlobal;

                    if (condA && condB && condC) {
                        varrefs.push(varref);
                        varrefsNames.push(varref.name);
                    }
                } catch (e) {
                    console.error(e);
                    console.log(varref.code);
                }
            }
        }
        this.#printMsg("Found " + varrefsNames.length + " external variable references inside outline region");
        return varrefs;
    }

    #isValidVarref(varref: Varref): boolean {
        // FIXME: EXTREMELY PATCHWORK SOLUTION UNTIL WE FIND SOMETHING BETTER
        const code = varref.code;
        const blacklist = [
            "<<",
            ">>",
            "+",
            "std::endl"
        ];
        return !blacklist.some(s => code.includes(s)) && !varref.isFunctionCall;
    }

    #findDeclsWithDependency(region: Statement[], epilogue: Statement[]): DeclStmt[] {
        const regionDecls = [];
        const regionDeclsNames = [];

        for (const stmt of region) {
            if (stmt instanceof DeclStmt) {
                regionDecls.push(stmt);
                const decl = stmt.children[0] as Vardecl;
                regionDeclsNames.push(decl.name);
            }
        }

        const epilogueVarrefsNames = [];
        for (const stmt of epilogue) {
            // also gets function names... could it cause an issue?
            for (const varref of Query.searchFrom(stmt, Varref)) {
                epilogueVarrefsNames.push(varref.name);
            }
        }

        const declsWithDependency = [];
        for (var i = 0; i < regionDecls.length; i++) {
            const varName = regionDeclsNames[i];
            if (epilogueVarrefsNames.includes(varName)) {
                declsWithDependency.push(regionDecls[i]);
            }
        }
        this.#printMsg("Found " + declsWithDependency.length + " declaration(s) referenced after the outline region");
        return declsWithDependency;
    }

    #splitRegions(fun: FunctionJp, begin: Statement, end: Statement) {
        const prologue = []
        const region = [];
        const epilogue = [];

        var inPrologue = true;
        var inRegion = false;
        for (const stmt of Query.searchFrom(fun, Statement)) {
            if (inPrologue) {
                if (stmt.astId == begin.astId) {
                    region.push(stmt);
                    inPrologue = false;
                    inRegion = true;
                }
                else {
                    prologue.push(stmt);
                }
            }
            if (inRegion) {
                // we only want statements at the scope level, we can get the children later
                if (stmt.parent.astId == begin.parent.astId) {
                    region.push(stmt);
                    if (stmt.astId == end.astId) {
                        inRegion = false;
                    }
                }
            }
            if (!inPrologue && !inRegion) {
                epilogue.push(stmt);
            }
        }
        return [prologue, region, epilogue];
    }

    #printMsg(msg: string, overrideVerbosity = false) {
        if (this.#verbose || overrideVerbosity)
            console.log("[Outliner] " + msg);
    }

    #generateFunctionName() {
        var name = IdGenerator.next(this.#defaultPrefix);
        return name;
    }
}