import ClavaJoinPoints from "@specs-feup/clava/api/clava/ClavaJoinPoints.js";
import { AdjustedType, ArrayType, BinaryOp, Break, BuiltinType, Call, Continue, DeclStmt, ElaboratedType, Expression, FunctionJp, GotoStmt, If, Joinpoint, LabelStmt, Literal, MemberAccess, Param, ParenExpr, PointerType, QualType, ReturnStmt, Scope, Statement, TypedefType, UnaryOp, Vardecl, Varref, WrapperStmt } from "@specs-feup/clava/api/Joinpoints.js";
import IdGenerator from "@specs-feup/lara/api/lara/util/IdGenerator.js";
import Query from "@specs-feup/lara/api/weaver/Query.js";
import { AdvancedTransform } from "../AdvancedTransform.js";
import { ScopeFlattener } from "../flattening/ScopeFlattener.js";

export class Outliner extends AdvancedTransform {
    private defaultPrefix: string;

    constructor(silent: boolean = false) {
        super("Outliner", silent);
        this.defaultPrefix = "__outlined_function_";
    }

    /**
     * Sets the prefix used for the autogenerated names of the outlined functions
     * @param {string} prefix - the prefix to be used
     */
    public setDefaultPrefix(prefix: string): void {
        this.defaultPrefix = prefix;
    }

    /**
     * Applies function outlining to a code region delimited by two statements.
     * Function outlining is the process of removing a section of code from a function and placing it in a new function.
     * The beginning and end of the code region must be at the same scope level.
     * @param {statement} begin - the first statement of the outlining region 
     * @param {statement} end - the last statement of the outlining region
     * @returns an array with the joinpoints of the outlined function and the call to it. 
     * These values are merely references, and all changes have already been committed to the AST at this point
     */
    public outline(begin: Statement, end: Statement, outlineAllDecls: boolean = false): [FunctionJp, Call] | [null, null] {
        return this.outlineWithName(begin, end, this.generateFunctionName(), outlineAllDecls)
    }

    public outlineWithWrappers(begin: WrapperStmt, end: WrapperStmt, outlineAllDecls: boolean = false): [FunctionJp, Call] | [null, null] {
        const beginPragma = begin.code.trim().replace(/\s+/g, ' ').replace(";", "");
        const endPragma = end.code.trim().replace(/\s+/g, ' ').replace(";", "");

        if (!beginPragma.toLowerCase().includes("#pragma clava begin_outline")) {
            this.logError("Provided begin wrapper is not a valid outlining pragma! Begin = " + beginPragma);
            return [null, null];
        }
        if (!endPragma.toLowerCase().includes("#pragma clava end_outline")) {
            this.logError("Provided end wrapper is not a valid outlining pragma! End = " + endPragma);
            return [null, null];
        }
        const funName = beginPragma.split(" ")[3] || this.generateFunctionName();

        // we need to get the statements immediately before and after the wrappers
        const beginStmt = begin.siblingsRight[0] as Statement;
        const endStmt = end.siblingsLeft[end.siblingsLeft.length - 1] as Statement;

        if (beginStmt == null || endStmt == null) {
            this.logError("Could not find the statements to outline! Begin = " + beginStmt + ", end = " + endStmt);
            return [null, null];
        }
        begin.detach();
        end.detach();

        return this.outlineWithName(beginStmt, endStmt, funName, outlineAllDecls);
    }

    /**
     * Applies function outlining to a code region delimited by two statements.
     * Function outlining is the process of removing a section of code from a function and placing it in a new function.
     * The beginning and end of the code region must be at the same scope level.
     * @param {statement} begin - the first statement of the outlining region 
     * @param {statement} end - the last statement of the outlining region
     * @param {string} functionName - the name to give to the outlined function
     * @returns an array with the joinpoints of the outlined function and the call to it. 
     * These values are merely references, and all changes have already been committed to the AST at this point
     */
    public outlineWithName(begin: Statement, end: Statement, functionName: string, outlineAllDecls: boolean = false): [FunctionJp, Call] | [null, null] {
        this.log("Attempting to outline a region into a function named \"" + functionName + "\"");

        //------------------------------------------------------------------------------
        if (!this.checkOutline(begin, end)) {
            this.logError("Provided code region is not outlinable! Aborting...");
            return [null, null];
        }
        this.log("Provided code region is outlinable");

        //------------------------------------------------------------------------------
        const wrappers = this.wrapBeginAndEnd(begin, end);
        begin = wrappers[0];
        end = wrappers[1];
        this.log("Wrapped outline region with begin and ending comments");

        //------------------------------------------------------------------------------
        //const parentFun: FunctionJp | null = this.findParentFunction(begin);
        const parentFun = begin.getAncestor("function") as FunctionJp | null;
        if (parentFun == null) {
            this.logError("Could not find parent function for the outline region");
            return [null, null];
        }
        const split = this.splitRegions(parentFun, begin, end);

        let region = split[1];
        const prologue = split[0];
        const epilogue = split[2];
        this.log("Found " + region.length + " statements for the outline region");
        this.log("Prologue has " + prologue.length + " statements, and epilogue has " + epilogue.length);

        //------------------------------------------------------------------------------
        // const flt = this.flattenScopes(region);
        // if (flt > 0) {
        //     this.log("Flattened " + flt + " scope(s) in the outline region");
        // }
        // else {
        //     this.log("No scopes were flattened in the outline region");
        // }

        //------------------------------------------------------------------------------
        const globals = this.findGlobalVars();
        this.log("Found " + globals.length + " global variable(s)");

        //------------------------------------------------------------------------------
        const callPlaceholder = ClavaJoinPoints.stmtLiteral("//placeholder for the call to " + functionName);
        begin.insertBefore(callPlaceholder);
        this.log("Created a placeholder call to the new function");

        //------------------------------------------------------------------------------
        if (!outlineAllDecls) {
            const declareBefore = this.findDeclsWithDependency(region, epilogue);
            region = region.filter((stmt) => !declareBefore.includes(stmt as DeclStmt));
            for (var i = declareBefore.length - 1; i >= 0; i--) {
                const decl = declareBefore[i];
                decl.detach();
                begin.insertBefore(decl);
                prologue.push(decl);
            }
            this.log("Moved declarations from outline region to immediately before the region");
        }

        //------------------------------------------------------------------------------
        const referencedInRegion = this.findRefsInRegion(region);
        const funParams = this.createParams(referencedInRegion);
        const fun = this.createFunction(functionName, region, funParams, referencedInRegion);
        this.log("Successfully created function \"" + functionName + "\"");

        //------------------------------------------------------------------------------
        const callArgs = this.createArgs(fun, prologue, parentFun);
        let call = this.updateCall(callPlaceholder, fun, callArgs);
        this.log("Successfully created call to \"" + functionName + "\"");

        //------------------------------------------------------------------------------
        // At this point, if the function has a premature return, it will be returning a value
        // of that type instead of void. We change the function to return void now at this point,
        // by doing a) adding a new parameter for the return value of the premature return; b) a new
        // boolean parameter that is set to true if the function returns prematurely; c) we declare these
        // two variables before the function call and d) if the boolean is set to 1 after the call, we
        // return from the caller with the value returned by the callee.
        const newCall = this.ensureVoidReturn(fun, call);
        if (newCall != null) {
            this.log("Ensured that the outlined function returns void by parameterizing the early return(s)");
            call = newCall;
        }
        else {
            this.log("No need to ensure that the outlined function returns void, as it has no early returns");
        }

        //------------------------------------------------------------------------------
        // Remove some of the redundancies introduced by the outlining process
        this.removeRedundancies(fun);
        this.removeRedundancies(call);
        this.log("Removed redundancies from the outlined function and the call to it");

        // ------------------------------------------------------------------------------
        // Deal with leftover breaks and continues
        this.removeContinues(fun, call);
        this.removeBreaks(fun, call);
        this.cleanupBreaks(fun);
        this.log("Removed leftover breaks and continues from the outlined function");

        //  ------------------------------------------------------------------------------
        // Apply some final transformations to solve edge cases
        this.transformPointerReassignments(fun, call);

        //------------------------------------------------------------------------------
        // Victory, at last
        begin.detach();
        end.detach();
        this.log("Finished cleanup");

        return [fun, call];
    }

    private transformPointerReassignments(fun: FunctionJp, call: Call): void {
        const reassignedPointerParams: Param[] = [];

        fun.params.forEach((param) => {
            if (param.type instanceof PointerType) {
                for (const varref of Query.searchFrom(fun.body, Varref, { name: param.name })) {
                    if (varref.parent instanceof BinaryOp) {
                        const binOp = varref.parent as BinaryOp;
                        if (binOp.isAssignment && binOp.left.code === varref.code) {
                            reassignedPointerParams.push(param);
                            break;
                        }
                    }
                }
            }
        });
        reassignedPointerParams.forEach((param) => {
            // Dereference every reference
            for (const varref of Query.searchFrom(fun, Varref, { name: param.name })) {
                if (varref.type.code !== param.type.code) {
                    continue;
                }
                const derefOp = ClavaJoinPoints.parenthesis(ClavaJoinPoints.unaryOp("*", varref));
                varref.replaceWith(derefOp);
            }
            // Change parameter to have another layer of indirection
            const oldType = param.type;
            const newType = ClavaJoinPoints.type(`${oldType.code}*`);
            param.setType(newType);

            // Change argument in the call
            const idx = fun.params.findIndex((p) => p.name === param.name);
            const arg = call.argList[idx];
            const addrOf = ClavaJoinPoints.unaryOp("&", ClavaJoinPoints.parenthesis(arg));
            call.setArg(idx, addrOf);

            this.log(`Transformed parameter "${param.name}" to a pointer to a pointer type`);
        });
    }

    private flattenScopes(region: Statement[]): number {
        const toFlatten: Scope[] = [];
        for (const stmt of region) {
            toFlatten.push(...Query.searchFromInclusive(stmt, Scope).get().filter((s) => s.joinPointType !== "body"));
        }

        const sf = new ScopeFlattener();
        toFlatten.forEach((scope) => {
            const prefix = IdGenerator.next("_s");
            sf.flattenScope(scope, true, prefix);
            this.log(`Flattened scope at line ${scope.line} with prefix "${prefix}"`);
        });
        return toFlatten.length;
    }

    // fixes some edge cases where we may end up with top-level code like
    // if(__prematureExit0 == 1) { break; }
    private cleanupBreaks(fun: FunctionJp): void {
        for (const stmt of fun.body.stmts) {
            if (stmt instanceof Break) {
                const returnStmt = ClavaJoinPoints.returnStmt();
                stmt.replaceWith(returnStmt);
            }

            if (stmt instanceof If) {
                for (const innerStmt of stmt.then.stmts) {
                    if (innerStmt.code == "break;") {
                        const returnStmt = ClavaJoinPoints.returnStmt();
                        innerStmt.replaceWith(returnStmt);
                    }
                }
                if (stmt.else != null) {
                    for (const innerStmt of stmt.else.stmts) {
                        if (innerStmt.code == "break;") {
                            const returnStmt = ClavaJoinPoints.returnStmt();
                            innerStmt.replaceWith(returnStmt);
                        }
                    }
                }
            }
        }
    }

    private removeContinuesDeprecated(fun: FunctionJp): void {
        for (const brk of Query.searchFrom(fun, Continue)) {
            if (brk.getAncestor("loop") == null) {
                const returnStmt = ClavaJoinPoints.returnStmt();
                brk.replaceWith(returnStmt);
            }
        }
    }

    private removeContinues(fun: FunctionJp, call: Call): void {
        const continues: Statement[] = [];
        // Although we have a Continue jp type, some continues may be a generic Statement type generated by stmtLiteral()
        // This code catches both cases
        for (const stmt of Query.searchFrom(fun, Statement)) {
            if (stmt.code == "continue;") {
                if (stmt.getAncestor("loop") == null && stmt.getAncestor("switch") == null) {
                    continues.push(stmt);
                }
            }
        }

        if (continues.length == 0) {
            return;
        }
        // Create premature exit variable
        const varName = IdGenerator.next("__doContinue");
        const preExitVar = ClavaJoinPoints.varDecl(varName, ClavaJoinPoints.integerLiteral(0));
        call.insertBefore(preExitVar);

        // Create premature exit arg
        const preExitVarRef = ClavaJoinPoints.varRef(preExitVar);
        const preExitVarAddr = ClavaJoinPoints.unaryOp("&", preExitVarRef);
        call.addArg(preExitVarAddr.code, preExitVarAddr.type);

        // Create early exit test and return
        const condStmt = ClavaJoinPoints.binaryOp("==", preExitVarRef, ClavaJoinPoints.integerLiteral(1));
        const continueStmt = ClavaJoinPoints.stmtLiteral("continue;");
        const ifStmt = ClavaJoinPoints.ifStmt(condStmt, ClavaJoinPoints.scope(continueStmt));
        call.insertAfter(ifStmt);

        // Create premature exit parameter
        const preExitParam = ClavaJoinPoints.param("__doContinue", ClavaJoinPoints.type("int*"));
        fun.addParam(preExitParam.name, preExitParam.type);

        // Replace continue with premature exit
        for (const cont of continues) {
            const assignStmt = ClavaJoinPoints.stmtLiteral(`*${preExitParam.name} = 1;`);
            const returnStmt = ClavaJoinPoints.returnStmt();

            cont.insertAfter(returnStmt);
            cont.replaceWith(assignStmt);
        }
    }

    private removeBreaks(fun: FunctionJp, call: Call): void {
        const breaks: Statement[] = [];
        // Although we have a Break jp type, some breaks may be a generic Statement type generated by stmtLiteral()
        // This code catches both cases
        for (const stmt of Query.searchFrom(fun, Statement)) {
            if (stmt.code == "break;") {
                if (stmt.getAncestor("loop") == null && stmt.getAncestor("switch") == null) {
                    breaks.push(stmt);
                }
            }
        }

        if (breaks.length == 0) {
            return;
        }
        // Create premature exit variable
        const varName = IdGenerator.next("__prematureExit");
        const preExitVar = ClavaJoinPoints.varDecl(varName, ClavaJoinPoints.integerLiteral(0));
        call.insertBefore(preExitVar);

        // Create premature exit arg
        const preExitVarRef = ClavaJoinPoints.varRef(preExitVar);
        const preExitVarAddr = ClavaJoinPoints.unaryOp("&", preExitVarRef);
        call.addArg(preExitVarAddr.code, preExitVarAddr.type);

        // Create early exit test and return
        const condStmt = ClavaJoinPoints.binaryOp("==", preExitVarRef, ClavaJoinPoints.integerLiteral(1));
        const breakOrReturnStmt = call.getAncestor("loop") ? ClavaJoinPoints.stmtLiteral("break;") : ClavaJoinPoints.returnStmt();
        const ifStmt = ClavaJoinPoints.ifStmt(condStmt, ClavaJoinPoints.scope(breakOrReturnStmt));
        call.insertAfter(ifStmt);

        // Create premature exit parameter
        const preExitParam = ClavaJoinPoints.param("_prematureExit", ClavaJoinPoints.type("int*"));
        fun.addParam(preExitParam.name, preExitParam.type);

        // Replace breaks with premature exit
        for (const brk of breaks) {
            const assignStmt = ClavaJoinPoints.stmtLiteral(`*${preExitParam.name} = 1;`);
            const returnStmt = ClavaJoinPoints.returnStmt();

            brk.insertAfter(returnStmt);
            brk.replaceWith(assignStmt);
        }
    }

    private removeRedundancies(startingPoint: Joinpoint): void {
        const unaryOps = [];

        for (const unaryOp of Query.searchFrom(startingPoint, UnaryOp)) {
            unaryOps.push(unaryOp);
        }

        for (const op of unaryOps) {
            if (op.children.length == 0) {
                continue;
            }
            const child = op.children[0];

            if (child instanceof ParenExpr) {
                const grandchild = child.children[0];

                const isValid = op.kind == "addr_of" && grandchild instanceof UnaryOp && grandchild.kind == "deref";
                if (isValid) {
                    op.replaceWith(grandchild.children[0]);
                }
            }
        }
    }

    /**
     * Verifies if a code region can undergo function outlining. 
     * This check is performed automatically by the outliner itself, but it can be invoked manually if desired.
     * @param {statement} begin - the first statement of the outlining region 
     * @param {statement} end - the last statement of the outlining region 
     * @returns true if the outlining region is valid, false otherwise
     */
    public checkOutline(begin: Statement, end: Statement): boolean {
        var outlinable = true;
        //const parentFun = this.findParentFunction(begin);
        const parentFun = begin.getAncestor("function") as FunctionJp | null;

        if (parentFun == null) {
            this.logError("Requirement not met: outlinable region must be inside a function");
            outlinable = false;
        }
        if (begin.parent.astId != end.parent.astId) {
            this.logError("Requirement not met: begin and end joinpoints are not at the same scope level");
            outlinable = false;
        }
        if (!outlinable) {
            return false;
        }

        // now that we have a baseline valid region, let's check for specific requirements within the region
        // TS conversion: we need to explicitly cast the parentFun to FunctionJp because it could be null,
        // despite having checked for it earlier
        const region = this.splitRegions(parentFun as FunctionJp, begin, end)[1];

        if (this.checkOutOfRegionGotos(region)) {
            this.logError("Requirement not met: outlinable region must not contain any goto statements that jump outside of the region");
            outlinable = false;
        }
        return outlinable;
    }

    private checkOutOfRegionGotos(region: Statement[]): boolean {
        const gotoLabels = [];
        const labels: string[] = [];

        for (const stmt of region) {
            for (const goto of Query.searchFrom(stmt, GotoStmt)) {
                gotoLabels.push(goto.label.code);
            }
            for (const label of Query.searchFrom(stmt, LabelStmt)) {
                labels.push(label.code);
            }
        }
        return !gotoLabels.every(label => labels.includes(label));
    }

    private ensureVoidReturn(fun: FunctionJp, call: Call): Call | null {
        const returnStmts = this.findNonvoidReturnStmts([fun]);
        if (returnStmts.length == 0) {
            return null;
        }

        const [returnValDecl, returnBoolDecl] = this.buildVoidReturnCallCheck(call);

        const newCall = this.updateCallForVoidReturn(fun, call, returnValDecl, returnBoolDecl);

        this.updateFunctionForVoidReturn(fun, returnStmts);
        return newCall;
    }

    private buildVoidReturnCallCheck(call: Call): [Vardecl, Vardecl] {
        const caller = call.getAncestor("function") as FunctionJp;
        const callerRetType = caller.type;

        const returnValName = IdGenerator.next("__rtr_val_");
        const returnValDecl = ClavaJoinPoints.varDeclNoInit(returnValName, callerRetType);
        call.insertBefore(returnValDecl);

        const returnBoolName = IdGenerator.next("__rtr_flag_");
        const returnBoolDecl = ClavaJoinPoints.varDecl(returnBoolName, ClavaJoinPoints.integerLiteral(0));
        call.insertBefore(returnBoolDecl);

        const returnValRef = returnValDecl.varref();
        const returnBoolRef = returnBoolDecl.varref();

        const returnStmt = ClavaJoinPoints.returnStmt(returnValRef);
        const scope = ClavaJoinPoints.scope();
        scope.setFirstChild(returnStmt);
        const ifStmt = ClavaJoinPoints.ifStmt(returnBoolRef, scope);
        call.insertAfter(ifStmt);

        return [returnValDecl, returnBoolDecl];
    }

    private updateCallForVoidReturn(fun: FunctionJp, call: Call, returnValDecl: Vardecl, returnBoolDecl: Vardecl): Call {
        const returnValPointerType = ClavaJoinPoints.pointer(returnValDecl.type);
        const returnBoolPointerType = ClavaJoinPoints.pointer(returnBoolDecl.type);

        const returnValParam = ClavaJoinPoints.param(returnValDecl.name, returnValPointerType);
        const returnBoolParam = ClavaJoinPoints.param(returnBoolDecl.name, returnBoolPointerType);
        fun.addParam(returnValParam.name, returnValParam.type);
        fun.addParam(returnBoolParam.name, returnBoolParam.type);
        fun.setType(ClavaJoinPoints.type("void"));

        const newArgList = call.argList.concat([
            ClavaJoinPoints.unaryOp("&", returnValDecl.varref()),
            ClavaJoinPoints.unaryOp("&", returnBoolDecl.varref())
        ]);
        const newCall = this.updateCall(call, fun, newArgList);
        return newCall;
    }

    private updateFunctionForVoidReturn(fun: FunctionJp, returnStmts: ReturnStmt[]): void {
        const returnVarParam = fun.params[fun.params.length - 2];
        const returnBoolParam = fun.params[fun.params.length - 1];

        for (const returnStmt of returnStmts) {
            // assign return value to the return variable
            const returnExpr = returnStmt.children[0] as Expression;
            returnExpr.detach();

            const returnVarParamRef = ClavaJoinPoints.varRef(returnVarParam);
            const derefReturnVarParam = ClavaJoinPoints.parenthesis(ClavaJoinPoints.unaryOp("*", returnVarParamRef));

            const assignment = ClavaJoinPoints.binaryOp("=", derefReturnVarParam, returnExpr, returnExpr.type);
            returnStmt.insertBefore(ClavaJoinPoints.exprStmt(assignment));

            // set return bool to 1
            const returnBoolParamRef = ClavaJoinPoints.varRef(returnBoolParam);
            const derefReturnBoolParam = ClavaJoinPoints.parenthesis(ClavaJoinPoints.unaryOp("*", returnBoolParamRef));

            const trueLiteral = ClavaJoinPoints.integerLiteral(1);

            const boolAssignment = ClavaJoinPoints.binaryOp("=", derefReturnBoolParam, trueLiteral, trueLiteral.type);
            returnStmt.insertBefore(ClavaJoinPoints.exprStmt(boolAssignment));
        }
    }

    private wrapBeginAndEnd(begin: Statement, end: Statement): [Statement, Statement] {
        const beginWrapper = ClavaJoinPoints.stmtLiteral("//begin of the outline region");
        const endWrapper = ClavaJoinPoints.stmtLiteral("//end of the outline region");
        begin.insertBefore(beginWrapper);
        end.insertAfter(endWrapper);
        return [beginWrapper, endWrapper];
    }

    private findGlobalVars() {
        const globals = [];
        for (const decl of Query.search(Vardecl)) {
            if (decl.isGlobal) {
                globals.push(decl);
            }
        }
        return globals;
    }

    private updateCall(oldCall: Statement | Call, fun: FunctionJp, args: Expression[]): Call {
        const call = ClavaJoinPoints.call(fun, ...args);
        oldCall.replaceWith(call);
        return call;
    }

    private createArgs(fun: FunctionJp, prologue: Statement[], parentFun: FunctionJp): Expression[] {
        const decls = [];
        // get decls from the prologue
        for (const stmt of prologue) {
            for (const decl of Query.searchFrom(stmt, Vardecl)) {
                decls.push(decl);
            }
        }
        // get decls from the parent function params
        for (const param of Query.searchFrom(parentFun, Param)) {
            decls.push(param.definition);
        }
        // no need to handle global vars - they are not parameters

        const args = [];
        for (const param of fun.params) {
            for (const decl of decls) {
                if (decl.name === param.name) {
                    const ref = ClavaJoinPoints.varRef(decl);

                    if (param.type instanceof PointerType) {
                        if (ref.type instanceof BuiltinType || ref.type instanceof TypedefType || ref.type instanceof ElaboratedType || ref.type instanceof QualType) {
                            const addressOfScalar = ClavaJoinPoints.unaryOp("&", ref);
                            args.push(addressOfScalar);
                        }
                        else {
                            args.push(ref);
                        }
                    }
                    else {
                        args.push(ref);
                    }
                    break;
                }
            }
        }

        return args;
    }

    private createFunction(name: string, region: Statement[], params: Param[], varrefs: Varref[]): FunctionJp {
        let oldFun: Joinpoint = region[0];
        while (!(oldFun instanceof FunctionJp)) {
            oldFun = oldFun.parent;
        }

        if (oldFun == null) {
            const msg = "Could not find parent function for the outline region";
            this.logError(msg);
            throw new Error(msg);
        }

        let retType = ClavaJoinPoints.type("void");
        const returnStmts = this.findNonvoidReturnStmts(region);
        if (returnStmts.length > 0) {
            retType = returnStmts[0].children[0].type;
            this.log("Found " + returnStmts.length + " return statement(s) in the outline region");
        }

        const fun = ClavaJoinPoints.functionDecl(name, retType, ...params);
        // const fun = ClavaJoinPoints.functionDecl(name, retType);
        // for (const param of params) {
        //     fun.addParam(param.name, param.type);
        // }

        oldFun.insertBefore(fun);
        const scope = ClavaJoinPoints.scope();
        fun.setBody(scope);

        for (const stmt of region) {
            stmt.detach();
            scope.insertEnd(stmt);
        }

        // make sure scalar refs are now dereferenced pointers to params
        this.scalarsToPointers(region, params, varrefs);
        return fun;
    }

    private findNonvoidReturnStmts(startingPoints: Joinpoint[]) {
        const returnStmts = [];
        for (const stmt of startingPoints) {
            for (const ret of Query.searchFrom(stmt, ReturnStmt)) {
                if (ret.numChildren > 0) {
                    returnStmts.push(ret);
                }
            }
        }
        return returnStmts;
    }

    private scalarsToPointers(region: Statement[], params: Param[], varrefs: Varref[]): void {
        for (const stmt of region) {

            for (const varref of varrefs) {

                for (const param of params) {
                    if (param.name === varref.name) {
                        if (varref.type instanceof ElaboratedType) {
                            const newVarref = ClavaJoinPoints.varRef(param);
                            varref.replaceWith(newVarref);
                        }
                        if (varref.type instanceof BuiltinType || varref.type instanceof TypedefType || varref.type instanceof QualType) {
                            const newVarref = ClavaJoinPoints.varRef(param);

                            if (varref.parent != undefined && varref.parent instanceof MemberAccess) {
                                varref.parent.setArrow(true);
                                varref.replaceWith(newVarref);
                            }
                            else {
                                const op = ClavaJoinPoints.parenthesis(ClavaJoinPoints.unaryOp("*", newVarref));
                                varref.replaceWith(op);
                            }

                        }
                    }
                }
            }
        }
    }

    private createParams(varrefs: Varref[]): Param[] {
        const params: Param[] = [];
        const uniqueNames = new Set();

        for (const ref of varrefs) {
            const name = ref.name;
            if (uniqueNames.has(name)) {
                continue;
            }
            uniqueNames.add(name);
            const varType = ref.type;

            if (varType instanceof AdjustedType || varType instanceof PointerType) {
                const param = ClavaJoinPoints.param(name, varType);
                params.push(param);
            }
            else if (varType instanceof ArrayType) {
                const baseType = varType.code.split("[")[0].trim();
                const newType = ClavaJoinPoints.pointer(ClavaJoinPoints.type(baseType));
                const param = ClavaJoinPoints.param(name, newType);
                params.push(param);
            }
            // unsure if typedefType is always a scalar
            else if (varType instanceof BuiltinType || varType instanceof TypedefType || varType instanceof ElaboratedType) {
                const newType = ClavaJoinPoints.pointer(varType);
                const param = ClavaJoinPoints.param(name, newType);
                params.push(param);
            }
            else if (varType instanceof QualType) {
                this.logWarning(`Found semi-supported type class "${varType.joinPointType}" for C/C++ type ${varType.code}`);
                const newType = ClavaJoinPoints.pointer(varType);
                const param = ClavaJoinPoints.param(name, newType);
                params.push(param);
            }
            else {
                this.logWarning(`Unsupported param type "${varType.joinPointType}" for C/C++ type ${varType.code}`);
            }
        }
        this.log("Created " + params.length + " param(s) for the outlined function");
        return params;
    }

    private findRefsInRegion(region: Statement[]): Varref[] {
        const varrefs: Varref[] = [];

        for (const stmt of region) {
            for (const varref of Query.searchFrom(stmt, Varref)) {
                // may need to filter for other types, like macros, etc
                // select all varrefs with no matching decl in the region, except globals
                const isValid = this.isValidVarref(varref);
                if (isValid) {
                    varrefs.push(varref);
                }
            }
        }

        const validVarrefs: Varref[] = [];
        for (const varref of varrefs) {
            //if (!this.declInPath(varref, stmtIds)) {
            if (!this.declInRegion(varref, region)) {
                validVarrefs.push(varref);
            }
        }
        // const uniqueRefs = new Set();
        // this.log("Found " + uniqueRefs.size + " external variable references inside outline region");
        // return validVarrefs.filter(varref => {
        //     if (!uniqueRefs.has(varref.name)) {
        //         uniqueRefs.add(varref.name);
        //         return true;
        //     }
        //     return false;
        // });
        this.log("Found " + validVarrefs.length + " external variable reference(s) inside outline region");
        return validVarrefs;
    }

    private declInRegion(varref: Varref, region: Statement[]): boolean {
        if (varref.vardecl === undefined) {
            return false;
        }
        if (varref.vardecl.isGlobal) {
            return true;
        }
        const stmtIds = region.map(stmt => stmt.astId);
        let varrefStmtId = "";
        let varrefParent: Joinpoint = varref;
        while (varrefParent != null) {
            if (stmtIds.includes(varrefParent.astId)) {
                varrefStmtId = varrefParent.astId;
                break;
            }
            varrefParent = varrefParent.getAncestor("statement");
        }

        for (const stmt of region) {
            for (const decl of Query.searchFrom(stmt, Vardecl, { name: varref.name })) {
                let declStmtId = "";
                let declParent: Joinpoint = decl;
                while (declParent != null) {
                    if (stmtIds.includes(declParent.astId)) {
                        declStmtId = declParent.astId;
                        break;
                    }
                    declParent = declParent.getAncestor("statement");
                }
                const varrefStmtIdx = stmtIds.indexOf(varrefStmtId);
                const declStmtIdx = stmtIds.indexOf(declStmtId);
                if (declStmtIdx >= 0 && varrefStmtIdx >= 0 && declStmtIdx <= varrefStmtIdx) {
                    return true;
                }
            }
        }
        return false;
    }

    private isValidVarref(varref: Varref): boolean {
        // FIXME: EXTREMELY PATCHWORK SOLUTION UNTIL WE FIND SOMETHING BETTER
        const code = varref.code;
        const blacklist = [
            "<<",
            ">>",
            "+",
            "std::endl"
        ];
        return !blacklist.some(s => code.includes(s)) && !varref.isFunctionCall;
    }

    private findDeclsWithDependency(region: Statement[], epilogue: Statement[]): DeclStmt[] {
        const regionDecls = [];
        const regionDeclsNames = [];

        for (const stmt of region) {
            if (stmt instanceof DeclStmt) {
                regionDecls.push(stmt);
                const decl = stmt.children[0] as Vardecl;
                regionDeclsNames.push(decl.name);
            }
        }

        const epilogueVarrefsNames = [];
        for (const stmt of epilogue) {
            // also gets function names... could it cause an issue?
            for (const varref of Query.searchFrom(stmt, Varref)) {
                epilogueVarrefsNames.push(varref.name);
            }
        }

        const declsWithDependency = [];
        for (var i = 0; i < regionDecls.length; i++) {
            const varName = regionDeclsNames[i];
            if (epilogueVarrefsNames.includes(varName)) {
                declsWithDependency.push(regionDecls[i]);
            }
        }
        this.log("Found " + declsWithDependency.length + " declaration(s) referenced after the outline region");
        return declsWithDependency;
    }

    private splitRegions(fun: FunctionJp, begin: Statement, end: Statement) {
        const prologue = []
        const region = [];
        const epilogue = [];

        var inPrologue = true;
        var inRegion = false;
        for (const stmt of Query.searchFrom(fun, Statement)) {
            if (inPrologue) {
                if (stmt.astId == begin.astId) {
                    region.push(stmt);
                    inPrologue = false;
                    inRegion = true;
                }
                else {
                    prologue.push(stmt);
                }
            }
            if (inRegion) {
                // we only want statements at the scope level, we can get the children later
                if (stmt.parent.astId == begin.parent.astId) {
                    region.push(stmt);
                    if (stmt.astId == end.astId) {
                        inRegion = false;
                    }
                }
            }
            if (!inPrologue && !inRegion) {
                epilogue.push(stmt);
            }
        }
        return [prologue, region, epilogue];
    }

    private generateFunctionName() {
        var name = IdGenerator.next(this.defaultPrefix);
        return name;
    }
}